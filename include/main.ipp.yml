version: '2'

mpp-vars:
  _sys:
    mpp-eval: "__import__('sys')"
  _uuid:
    mpp-eval: "__import__('uuid')"
  _json:
    mpp-eval: "__import__('json')"
  _yaml:
    mpp-eval: "__import__('yaml')"
  _datetime:
    mpp-eval: "__import__('datetime')"
  _re:
    mpp-eval: "__import__('re')"
  _printerr:
    mpp-eval: "lambda errstr: print('Error: ' + errstr, file=_sys.stderr)"
  _error:
    mpp-eval: "lambda errstr:(_printerr(errstr), _sys.exit(1))"
  # Helper to lazily compute a variable at a later time. This is used
  # to use the rpms[] variables which is update after evaluating
  # all the mpp-defines in the includes.
  _Lazy:
    mpp-eval: |
      type(
          "Lazy",
          (),
          {
              "__slots__": ("_func", "_has", "_val"),
              "__init__": lambda self, func: (
                  setattr(self, "_func", func),
                  setattr(self, "_has", False),
                  setattr(self, "_val", None)
              )[-1],
              "get": lambda self: (
                  self._val if getattr(self, "_has", False)
                  else (
                      setattr(self, "_val", self._func()),
                      setattr(self, "_has", True),
                      self._val
                  )[-1]
              ),
              "__call__": lambda self: self.get(),
              "_eval":  lambda self, x: x.get() if isinstance(x, self.__class__) else x,
              "__add__": lambda self, other: self.__class__(
                  lambda: self.get() + self._eval(other)
              ),
              "__radd__": lambda self, other: self.__class__(
                  lambda: self._eval(other) + self.get()
              ),
          },
      )
  _m:
    mpp-eval: |
      lambda x, _m: (
        x.get() if isinstance(x, _Lazy)
        else {k: _m(v, _m) for k, v in x.items()} if isinstance(x, dict)
        else type(x)(_m(v, _m) for v in x) if isinstance(x, (list, tuple, set))
        else x
      )
  # Materialize can be used to ensure all Lazy objects in a structure are resolved
  _materialize:
    mpp-eval: |
      lambda x: _m(x, _m)
  rpms: {} # Forward declare so it is in scope for later Lazy resolve
  installed_rpm:
    mpp-eval: |
      lambda rpm: rpms['rootfs'][rpm] if rpm in rpms['rootfs'] else _error(f"rpm '{rpm}' was unexpectedly not installed in the rootfs")
  # Helper to look up by regexp in a dict, default is last item
  regexp_lookup:
    mpp-eval: |
      lambda data, lookup:  next((v for k, v in data.items() if _re.fullmatch(k, lookup)), next(reversed(data.values())))

pipelines:
  - mpp-import-pipelines:
      path: defaults.ipp.yml
  - mpp-import-pipelines:
      path: data.ipp.yml
  - mpp-import-pipelines:
      path: distro/$distro_name.ipp.yml
  - mpp-import-pipelines:
      path: targets/$target.ipp.yml
  - mpp-import-pipelines:
      path: arch-$arch.ipp.yml
  - mpp-import-pipelines:
      path: defaults-computed.ipp.yml

  # At this point, the per arch/target/distro defaults are computed and are available
  # to the user supplied manifest to look at and override.

  - mpp-import-pipelines:
      path: $_workdir/manifest-variables.ipp.yml

  # Compute various derived variables after the end user manifest variables are set
  - mpp-import-pipelines:
      path: computed-vars.ipp.yml
  - mpp-import-pipelines:
      path: build.ipp.yml
  - mpp-import-pipelines:
      path: include/$qm_importfile.ipp.yml
  - mpp-import-pipelines:
      path: $_workdir/manifest.ipp.yml
  - mpp-import-pipelines:
      path: content.ipp.yml
  - mpp-import-pipelines:
      path: mode-$image_mode.ipp.yml
  - mpp-import-pipelines:
      path: image.ipp.yml
